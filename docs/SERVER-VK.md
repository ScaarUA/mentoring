JSMP3.6: JavaScript on Backend (Kotliar Vitalii)
===================

Используемые технологии
-------------
Для реализации сервера было использовано фреймворк **Express.js**, на котором базируется архитектура данного приложения. В качестве базы данных используется удаленная **MongoDB** на сервисе mlab.com, для управления БД задействован пакет NPM  - **mongoose**. 
На сервере предусматривается загрузка и выгрузка файлов, для этого был подключен **multer** — пакет для обработки форм типа multipart/form-data, которые, как правило, используют для передачи файлов. Также есть возможность выбора загрузки файла на сервер или облачное хранилище cloudinary.  Облако **cloudinary** специализируется на хранении изображений, для этого предоставляется широкий API, который позволяет: выполнять CRUD операции, изменять размеры, применять различные фильтры. Используя облако, мы сможем избежать потери данных, значительно уменьшить потребление памяти и уменьшить количество запросов на сервер, так как изображение будут получаться напрямую с облака, все вышеперечисленные пункты  значительно повысят быстродействие сервера.

----------

Схема базы данных
-----------------
![N|DB](/DB.png)



Реализация сервера
-------------

Архитектура сервера предусматривает компонентную структуру, каждая сущность лежит в отдельной папке и включает следующий набор файлов:
> - index.js — описывает маршруты и методы запросов;
> -   entity.controllers.js — содержит контроллеры для обработки маршрута;
> -   entity.model.js — содержит модель Mongoose;
> -   entity.queries.js —  описывает запросы Mongoose к базе данных;
> -   entity.services.js — содержит набор методов, которые используются  в контроллере данной  или других сущностей.

## Базовый контроллер 

Любая из сущностей имеет стандартный набор CRUD операций, и только некоторые операции обладают отличиями, поэтому существует необходимость в базовых контроллерах, от которого наследуются другие, что уменьшит дублирование кода. Такой класс был реализован и лежит в папке /server/helpers/base.controllers. 
К примеру сущность flow наследует base.controllers, за счет чего выполняются все CRUD операции. 
````
class FlowControllers extends BaseControllers {
    constructor() {
        super(Flow);
    }
}
````
 
## Обработка ошибок 

Ошибки сервера перехватываются и обрабатываются при помощи middleware, который находиться по пути /server/helpers/errorsHandler. Для создания ошибки можно использовать класс /server/helpers/ApiErrors.js, который расширяет стандартный класс Error, и добавляет поле статуса запроса. Для перехода к middleware ошибки в основном используется коллбек next, как показано на примере ниже.  
````
download(req, res, next) {
        return stateQueries.getState(id)
            .then((state) => {
                return res.status(200).download(state.image.path, state.image.name);
            })
            .catch(next);
    }
````  
## Сущность Flows 

Данная сущность имеет стандартный набор CRUD операций, реализованных по архитектуре REST.
> GET, POST  /api/flows  
GET, PUT, DELET  /api/flows/:id  

Все контроллеры данных маршрутов наследуются с класса base.controllers. 

## Сущность State 
Имеет стандартный набор CRUD операций, реализованных по архитектуре REST. 
> GET, POST  /api/states  
GET, PUT, DELET  /api/states/:id  
GET /api/states/:id/image   

Создание, редактирования, удаление и загрузка имеет ряд особенностей описанных ниже.

### Create(req, res, next) 
Метод в зависимости от параметра req.body.onCloud загружает файл на сервер или же на облако. Если загрузка выполняется на облако, то происходит в три этапа:
>- загрузка на сервер в папку /uploads;
>- загрузка на облако cloudinary;
>- удаление файла с папки /uploads.

### Update(req, res, next) 
Сложностью метода является потребность в удалении прошлого файла с сервера и  загрузка нового. Возникает 4 возможных стратегии: 
>- прошлый файл на сервере, новый нужно загрузить на облако;
>-  прошлый файл на сервер, загрузка на сервер;
>-  прошлый на облаке, загрузка нового на сервер;
>-  прошлый на облаке, загрузка нового на облако.

Работу метода изобразить таким образом:   

![N|Update](/update.png)


1) через multer загружаем файл на сервер, на этом этапе проверяется расширение файла и размеры;   
2) получаем объект из БД, и в зависимости от переменной onCloud удаляем прошлое изображения с сервера или с облака;  
3) если переменная req.body.onCloud равна true, то происходит загрузка на облако, после успешной загрузки, файл удаляется с папки /uploads;  
4) объект state сохраняется в БД. В поле state.image.path указывается путь на севере либо ссылка на изображении на облаке.   
Пример ниже:

`````
const state = {
    _id: '57f03136cd71f72b23150a2f',
    title: 'title',
    description: '2222',
    edited: '2016-10-01T21:57:10.533Z',
    created: '2016-10-01T21:57:10.533Z',
    hotspots: [],
    image: {
        onCloud: true,
        path: 'http://res.cloudinary.com/dkqdb6kwz/image/upload/v1475359030/ux0niw3eda4lgedfor8a.png',
        public_id: 'ux0niw3eda4lgedfor8a'
    }
}
`````

### Remove(req, res, next) 
Метод удаляет как документ из коллекции так и сам файл, в зависимости от переменной onCloud, изображение удаляется с сервера или облака.

### Download(req, res, next) 
Метод позволяет загрузить изображение с сервера

-------
Демонстрация работы с файлами
-------------
Для того что бы проверить работу с файлами была разработана небольшая FE часть в папке /mock_ui, используя ее можно проверить создание, обновление, загрузку и выгрузку файлов на сервер/облако. 
Что бы запустить /mock_ui необходимо:  
1) npm i;  
2) npm start;    
3) go http://localhost:8888/     

